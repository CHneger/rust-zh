## 条件

Rust 中的 `if` 并不是很复杂，但相比传统的系统语言，它更像动态语言中的 `if`。下面我们来讨论一下，抓住它的含义。

`if` 是更广泛概念“分支”的一种特殊形式。它的命名抽象自树的分支：基于选择的决策点，可能会有多种选择。（译者注：这段不知道怎么翻）

如果只有一个 `if`，就只有一个选择，导致两条道路：

```rust
let x = 5i;

if x == 5i {
    println!("x is five!");
}
```

如果我们在某个地方改变了 `x` 的值，这一行就不会打印出来。更具体地说，如果 `if` 后面的表达式计算结果为 `true`，这个条件语句块就会被执行；如果结果是 `false`，则不会执行。

如果你想在条件结果为 `false` 的时候发生点什么，那就用 `else`：

```{rust}
let x = 5i;

if x == 5i {
    println!("x is five!");
} else {
    println!("x is not five :(");
}
```

这些都是很标准的。然而，你也可以这样写：

```{rust}
let x = 5i;

let y = if x == 5i {
    10i
} else {
    15i
};
```

紧凑一点，可以像下面这样（也是推荐写法）：

```{rust}
let x = 5i;

let y = if x == 5i { 10i } else { 15i };
```

这个例子提示了 Rust 的两个有趣的东西：它是一种基于表达式的语言，而分号的作用也不同于其它“大括号-分号”形式系的语言。这两个东西是相关联的。

### 表达式 vs. 语句

Rust 主要是基于表达式的语言。它只有两种语句，除此之外，其它都是表达式。

区别在哪儿呢？表达式有返回值，而语句没有。在许多语言里面，`if` 是一个语句，因此，像 `let x = if ...` 这种写法是没有意义的。但在 Rust 中，`if` 是一个表达式，意味着它可以返回一个值。我们可以使用这个值来初始化绑定。

说到这儿，绑定正是 Rust 两种语句中的一种。正确的名称叫 **声明语句**。目前，`let` 是我们见过的唯一一种声明语句。后面还会遇到其它一些。

在一些语言中，变量绑定可以写成表达式，而不止是语句形式。比如 Ruby：

```{ruby}
x = y = 5
```

然而在 Rust 中，使用 `let` 来引入一个绑定，这 `不是` 一个表达式。下面的写法会导致一个编译时错误：

```{ignore}
let x = (let y = 5i); // expected identifier, found keyword `let`
```

编译器告诉我们它希望看到一个表达式的开始，但 `let` 是一个语句的开始，而不是表达式。

注意，给一个已绑定的变量（比如：`y = 5i`）赋值，这仍然是一个表达式，尽管这个表达式的返回值不一定有用。不像 C，赋值的返回结果就是右边的值（比如，前一个例子中的 `5i`），Rust 的赋值表达式的返回值是单元类型 `()` （后面会谈到这个）。

第二种语句，是 **表达式语句**。设计这个的目的是将任意表达式转化成语句。实际上，Rust 的语法期望一个语句跟着另一个语句。这就需要使用分号来分隔开表达式。这就导致 Rust 看起来跟其它很多语言一样了，要求你在每行的结尾跟一个分号。正如你会看到的，Rust 程序基本上每行的结尾都是跟了分号的。

我们刚才说“基本上”，那什么是例外呢？其实你已经看到了，在这片代码里面：

```{rust}
let x = 5i;

let y: int = if x == 5i { 10i } else { 15i };
```

注意我已经为 `y` 加上了类型注解，以显式地指定我们期望 `y` 是一个整数。

下面这样写是无法编译的：

```{ignore}
let x = 5i;

let y: int = if x == 5i { 10i; } else { 15i; };
```
注意到 10 和 15 后面的分号没？Rust 会给出下面的错误：

```{ignore,notrust}
error: mismatched types: expected `int` but found `()` (expected int but found ())
```

我们希望得到整数，但我们却得到 `()`. `()` 念作“单元”，是 Rust 类型系统中的一个特殊类型。在 Rust 中，`()` 不是一个整形变量的有效值。它只是一个 `()` 类型变量的有效值，虽然这并没多大用处。还记得我们为什么说语句是不返回值的不？好了，这种情况正是我们设计单元类型的目的。分号将任意表达式都转换成语句，扔掉表达式原来的返回值，然后返回一个单元 `()`。

Rust中，一行不以分号结尾，还有一种情况，那就是：函数。
