
## 复合数据类型

跟许多编程语言一样，Rust 有很多内建的数据类型。你已经用整数和字符串做了一些练习，下面，我们来讨论一些存储数据更复杂的方式。

### 元组

第一种复合数据类型叫 **元组**。元组是固定大小的顺序列表。比如这个：

```rust
let x = (1i, "hello");
```

括号和逗号构成了上面长度为 2 的元组。下面是同样的代码，只不过加上了类型注解：

```rust
let x: (int, &str) = (1, "hello");
```

正如你所见，元组类型看起来就像元组，但每个位置上都是类型名，而不是值。细心的读者可能会发现元组也是异质的：可以在一个元组里面放 `int` 和 `&str`。`&str` 这个你之前应该没见过，后面会仔细讨论的。在系统编程语言中，字符串有点复杂。现在只需要把 `&str` 读成“字符串切片” 就可以了。

可以使用 **析构 let** 来访问元组中的域。下面是例子：


```rust
let (x, y, z) = (1i, 2i, 3i);

println!("x is {}", x);
```

记得之前我们说过 `let` 语句左边部分不是简单的变量绑定吧。它是一种模式，就像上面例子一样，它会匹配右边的内容，可以实现一次多个变量的绑定。在这种情况下，`let` 析构，或打破了元组，把相应的位置的值赋给 3 个绑定。

这种模式非常强大，我们后面还会继续感受到。

没有析构，你也能用元组做一些事情。你可以把一个元组赋给另外一个，前提是它们有相同的元组类型（数目加对应的域类型）。

```rust
let mut x = (1i, 2i);
let y = (2i, 3i);

x = y;
```

你也可以用 `==` 来做相等性比较。但必须要元组类型和值完全一致，才会返回 `true`。

```rust
let x = (1i, 2i, 3i);
let y = (2i, 2i, 4i);

if x == y {
    println!("yes");
} else {
    println!("no");
}
```

这个例子会打印 `no`，因为两个元组有些值是不同的。

元组的另外一个作用是从函数中返回多个值：

```rust
fn next_two(x: int) -> (int, int) { (x + 1i, x + 2i) }

fn main() {
    let (x, y) = next_two(5i);
    println!("x, y = {}, {}", x, y);
}
```

其实 Rust 函数只能返回一个值，但元组可以在自己里面封装多个值，作为一个整体打包返回。然后在外面使用对应的模式进行析构，来取出多个返回值。

元组是非常简单的数据结构，一般满足不了你的。下面来讲一讲 结构体。

### 结构体


A struct is another form of a 'record type,' just like a tuple. There's a
difference: structs give each element that they contain a name, called a
'field' or a 'member.' Check it out:

```rust
struct Point {
    x: int,
    y: int,
}

fn main() {
    let origin = Point { x: 0i, y: 0i };

    println!("The origin is at ({}, {})", origin.x, origin.y);
}
```

There's a lot going on here, so let's break it down. We declare a struct with
the `struct` keyword, and then with a name. By convention, structs begin with a
capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.

We can create an instance of our struct via `let`, as usual, but we use a `key:
value` style syntax to set each field. The order doesn't need to be the same as
in the original declaration.

Finally, because fields have names, we can access the field through dot
notation: `origin.x`.

The values in structs are immutable, like other bindings in Rust. However, you
can use `mut` to make them mutable:

```{rust}
struct Point {
    x: int,
    y: int,
}

fn main() {
    let mut point = Point { x: 0i, y: 0i };

    point.x = 5;

    println!("The point is at ({}, {})", point.x, point.y);
}
```

This will print `The point is at (5, 0)`.

## Tuple Structs and Newtypes

Rust has another data type that's like a hybrid between a tuple and a struct,
called a **tuple struct**. Tuple structs do have a name, but their fields
don't:


```{rust}
struct Color(int, int, int);
struct Point(int, int, int);
```

These two will not be equal, even if they have the same values:

```{rust,ignore}
let black  = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

It is almost always better to use a struct than a tuple struct. We would write
`Color` and `Point` like this instead:

```{rust}
struct Color {
    red: int,
    blue: int,
    green: int,
}

struct Point {
    x: int,
    y: int,
    z: int,
}
```

Now, we have actual names, rather than positions. Good names are important,
and with a struct, we have actual names.

There _is_ one case when a tuple struct is very useful, though, and that's a
tuple struct with only one element. We call this a 'newtype,' because it lets
you create a new type that's a synonym for another one:

```{rust}
struct Inches(int);

let length = Inches(10);

let Inches(integer_length) = length;
println!("length is {} inches", integer_length);
```

As you can see here, you can extract the inner integer type through a
destructuring `let`.

## Enums

Finally, Rust has a "sum type", an **enum**. Enums are an incredibly useful
feature of Rust, and are used throughout the standard library. This is an enum
that is provided by the Rust standard library:

```{rust}
enum Ordering {
    Less,
    Equal,
    Greater,
}
```

An `Ordering` can only be _one_ of `Less`, `Equal`, or `Greater` at any given
time. Here's an example:

```{rust}
fn cmp(a: int, b: int) -> Ordering {
    if a < b { Less }
    else if a > b { Greater }
    else { Equal }
}

fn main() {
    let x = 5i;
    let y = 10i;

    let ordering = cmp(x, y);

    if ordering == Less {
        println!("less");
    } else if ordering == Greater {
        println!("greater");
    } else if ordering == Equal {
        println!("equal");
    }
}
```

`cmp` is a function that compares two things, and returns an `Ordering`. We
return either `Less`, `Greater`, or `Equal`, depending on if the two values
are greater, less, or equal.

The `ordering` variable has the type `Ordering`, and so contains one of the
three values. We can then do a bunch of `if`/`else` comparisons to check
which one it is.

However, repeated `if`/`else` comparisons get quite tedious. Rust has a feature
that not only makes them nicer to read, but also makes sure that you never
miss a case. Before we get to that, though, let's talk about another kind of
enum: one with values.

This enum has two variants, one of which has a value:

```{rust}
enum OptionalInt {
    Value(int),
    Missing,
}
```

This enum represents an `int` that we may or may not have. In the `Missing`
case, we have no value, but in the `Value` case, we do. This enum is specific
to `int`s, though. We can make it usable by any type, but we haven't quite
gotten there yet!

You can also have any number of values in an enum:

```{rust}
enum OptionalColor {
    Color(int, int, int),
    Missing,
}
```

And you can also have something like this:

```{rust}
enum StringResult {
    StringOK(String),
    ErrorReason(String),
}
```
Where a `StringResult` is either an `StringOK`, with the result of a computation, or an
`ErrorReason` with a `String` explaining what caused the computation to fail. These kinds of
`enum`s are actually very useful and are even part of the standard library.

As you can see `enum`s with values are quite a powerful tool for data representation,
and can be even more useful when they're generic across types. But before we get to
generics, let's talk about how to use them with pattern matching, a tool that will
let us deconstruct this sum type (the type theory term for enums) in a very elegant
way and avoid all these messy `if`/`else`s.
